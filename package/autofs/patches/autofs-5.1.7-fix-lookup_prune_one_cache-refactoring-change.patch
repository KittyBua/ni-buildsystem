autofs-5.1.7 - fix lookup_prune_one_cache() refactoring change

From: Ian Kent <raven@themaw.net>

Commit 256963d6b (autofs-5.1.7 - refactor lookup_prune_one_cache() a bit)
changed the position of the getting the next enumeration map entry but
failed to update a couple of other locations that assume the next map
entry has been set. Under certain fairly common conditions this leads
to an infinite loop.

Signed-off-by: Ian Kent <raven@themaw.net>
---
 CHANGELOG       |    1 +
 daemon/lookup.c |    5 ++++-
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/CHANGELOG b/CHANGELOG
index 51e7767e..698cc27a 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -69,6 +69,7 @@
 - fix amd section mounts map reload.
 - fix dandling symlink creation if nis support is not available.
 - dont use AUTOFS_DEV_IOCTL_CLOSEMOUNT.
+- fix lookup_prune_one_cache() refactoring change.
 
 25/01/2021 autofs-5.1.7
 - make bind mounts propagation slave by default.
diff --git a/daemon/lookup.c b/daemon/lookup.c
index 3e9722e4..0b281f83 100644
--- a/daemon/lookup.c
+++ b/daemon/lookup.c
@@ -1379,6 +1379,7 @@ void lookup_prune_one_cache(struct autofs_point *ap, struct mapent_cache *mc, ti
 		if (!key || strchr(key, '*')) {
 			if (key)
 				free(key);
+			me = cache_enumerate(mc, me);
 			continue;
 		}
 
@@ -1386,6 +1387,7 @@ void lookup_prune_one_cache(struct autofs_point *ap, struct mapent_cache *mc, ti
 		if (!path) {
 			warn(ap->logopt, "can't malloc storage for path");
 			free(key);
+			me = cache_enumerate(mc, me);
 			continue;
 		}
 
@@ -1413,9 +1415,10 @@ void lookup_prune_one_cache(struct autofs_point *ap, struct mapent_cache *mc, ti
 		}
 		if (!valid &&
 		    is_mounted(path, MNTS_REAL)) {
-			debug(ap->logopt, "prune posponed, %s mounted", path);
+			debug(ap->logopt, "prune postponed, %s mounted", path);
 			free(key);
 			free(path);
+			me = cache_enumerate(mc, me);
 			continue;
 		}
 		if (valid)
