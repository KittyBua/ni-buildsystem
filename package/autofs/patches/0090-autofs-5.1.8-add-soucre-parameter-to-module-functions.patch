autofs-5.1.8 - add soucre parameter to module functions

From: Ian Kent <raven@themaw.net>

There's a unnecessarily complicated method used to pass the map source
to module read map and lookup mount functions. This also confuses
coverity which constantly complains about unmatched locking.

Just add a parameter to those functions to simplify it and elliminate
the coverity false positives not to mention slightly less overhead by
the lock removal.

Signed-off-by: Ian Kent <raven@themaw.net>
---
 CHANGELOG                 |    1 +
 daemon/lookup.c           |   10 +------
 daemon/master.c           |   57 ----------------------------------------
 include/automount.h       |   16 ++++++-----
 include/master.h          |    4 ---
 modules/lookup_dir.c      |    8 +-----
 modules/lookup_file.c     |   29 +++++---------------
 modules/lookup_hesiod.c   |   15 +++--------
 modules/lookup_hosts.c    |   36 +++++++------------------
 modules/lookup_ldap.c     |   35 ++++++++-----------------
 modules/lookup_multi.c    |   24 ++++-------------
 modules/lookup_nisplus.c  |   27 +++++--------------
 modules/lookup_program.c  |   29 ++++++--------------
 modules/lookup_sss.c      |   64 +++++++++++----------------------------------
 modules/lookup_userhome.c |   16 +++--------
 modules/lookup_yp.c       |   35 ++++++++-----------------
 modules/parse_amd.c       |   16 ++++-------
 modules/parse_hesiod.c    |    8 ++----
 modules/parse_sun.c       |   15 ++++-------
 19 files changed, 112 insertions(+), 333 deletions(-)

diff --git a/CHANGELOG b/CHANGELOG
index ebd02b8c..998fe63f 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -87,6 +87,7 @@
 - dont take parent source lock at mount shutdown.
 - fix possible use after free in handle_mounts_exit().
 - make submount cleanup the same as top level mounts.
+- add soucre parameter to module functions.
 
 19/10/2021 autofs-5.1.8
 - add xdr_exports().
diff --git a/daemon/lookup.c b/daemon/lookup.c
index 0bfbaa5f..a3f660af 100644
--- a/daemon/lookup.c
+++ b/daemon/lookup.c
@@ -363,13 +363,10 @@ static int do_read_map(struct autofs_point *ap, struct map_source *map, time_t a
 		map_module_unlock(map);
 	}
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = map;
-
 	pthread_cleanup_push(map_module_lock_cleanup, map);
 	map_module_readlock(map);
 	lookup = map->lookup;
-	status = lookup->lookup_read_map(ap, age, lookup->context);
+	status = lookup->lookup_read_map(ap, map, age, lookup->context);
 	pthread_cleanup_pop(1);
 
 	if (status != NSS_STATUS_SUCCESS)
@@ -831,12 +828,9 @@ int do_lookup_mount(struct autofs_point *ap, struct map_source *map, const char
 		map_module_unlock(map);
 	}
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = map;
-
 	map_module_readlock(map);
 	lookup = map->lookup;
-	status = lookup->lookup_mount(ap, name, name_len, lookup->context);
+	status = lookup->lookup_mount(ap, map, name, name_len, lookup->context);
 	map_module_unlock(map);
 
 	return status;
diff --git a/daemon/master.c b/daemon/master.c
index 77dc7694..d23954ee 100644
--- a/daemon/master.c
+++ b/daemon/master.c
@@ -688,47 +688,6 @@ void master_source_lock_cleanup(void *arg)
 	return;
 }
 
-void master_source_current_wait(struct master_mapent *entry)
-{
-	int status;
-
-	status = pthread_mutex_lock(&entry->current_mutex);
-	if (status) {
-		logmsg("entry current source lock failed");
-		fatal(status);
-	}
-
-	while (entry->current != NULL) {
-		status = pthread_cond_wait(
-				&entry->current_cond, &entry->current_mutex);
-		if (status) {
-			logmsg("entry current source condition wait failed");
-			fatal(status);
-		}
-	}
-
-	return;
-}
-
-void master_source_current_signal(struct master_mapent *entry)
-{
-	int status;
-
-	status = pthread_cond_signal(&entry->current_cond);
-	if (status) {
-		logmsg("entry current source condition signal failed");
-		fatal(status);
-	}
-
-	status = pthread_mutex_unlock(&entry->current_mutex);
-	if (status) {
-		logmsg("entry current source unlock failed");
-		fatal(status);
-	}
-
-	return;
-}
-
 struct master_mapent *master_find_mapent(struct master *master, const char *path)
 {
 	struct list_head *head, *p;
@@ -851,14 +810,6 @@ struct master_mapent *master_new_mapent(struct master *master, const char *path,
 	if (status)
 		fatal(status);
 
-	status = pthread_mutex_init(&entry->current_mutex, NULL);
-	if (status)
-		fatal(status);
-
-	status = pthread_cond_init(&entry->current_cond, NULL);
-	if (status)
-		fatal(status);
-
 	INIT_LIST_HEAD(&entry->list);
 
 	return entry;
@@ -926,14 +877,6 @@ void master_free_mapent(struct master_mapent *entry)
 	if (status)
 		fatal(status);
 
-	status = pthread_mutex_destroy(&entry->current_mutex);
-	if (status)
-		fatal(status);
-
-	status = pthread_cond_destroy(&entry->current_cond);
-	if (status)
-		fatal(status);
-
 	free(entry);
 
 	return;
diff --git a/include/automount.h b/include/automount.h
index d6ca1ce5..77ff0c70 100644
--- a/include/automount.h
+++ b/include/automount.h
@@ -287,15 +287,15 @@ int lookup_source_close_ioctlfd(struct autofs_point *ap, const char *key);
 int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **context);
 int lookup_reinit(const char *mapfmt, int argc, const char *const *argv, void **context);
 int lookup_read_master(struct master *master, time_t age, void *context);
-int lookup_read_map(struct autofs_point *, time_t, void *context);
-int lookup_mount(struct autofs_point *, const char *, int, void *);
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context);
+int lookup_mount(struct autofs_point *, struct map_source *map, const char *name, int name_len, void *context);
 int lookup_done(void *);
 #endif
 typedef int (*lookup_init_t) (const char *, int, const char *const *, void **);
 typedef int (*lookup_reinit_t) (const char *, int, const char *const *, void **);
 typedef int (*lookup_read_master_t) (struct master *master, time_t, void *);
-typedef int (*lookup_read_map_t) (struct autofs_point *, time_t, void *);
-typedef int (*lookup_mount_t) (struct autofs_point *, const char *, int, void *);
+typedef int (*lookup_read_map_t) (struct autofs_point *, struct map_source *, time_t, void *);
+typedef int (*lookup_mount_t) (struct autofs_point *, struct map_source *, const char *, int, void *);
 typedef int (*lookup_done_t) (void *);
 
 struct lookup_mod {
@@ -324,13 +324,15 @@ int close_lookup(struct lookup_mod *);
 #ifdef MODULE_PARSE
 int parse_init(int argc, const char *const *argv, void **context);
 int parse_reinit(int argc, const char *const *argv, void **context);
-int parse_mount(struct autofs_point *ap, const char *name,
-		int name_len, const char *mapent, void *context);
+int parse_mount(struct autofs_point *ap, struct map_source *map,
+		const char *name, int name_len, const char *mapent,
+		void *context);
 int parse_done(void *);
 #endif
 typedef int (*parse_init_t) (int, const char *const *, void **);
 typedef int (*parse_reinit_t) (int, const char *const *, void **);
-typedef int (*parse_mount_t) (struct autofs_point *, const char *, int, const char *, void *);
+typedef int (*parse_mount_t) (struct autofs_point *, struct map_source *,
+				const char *, int, const char *, void *);
 typedef int (*parse_done_t) (void *);
 
 struct parse_mod {
diff --git a/include/master.h b/include/master.h
index 0bdef42e..38070bfc 100644
--- a/include/master.h
+++ b/include/master.h
@@ -49,8 +49,6 @@ struct master_mapent {
 	time_t age;
 	struct master *master;
 	pthread_rwlock_t source_lock;
-	pthread_mutex_t current_mutex;
-	pthread_cond_t current_cond;
 	struct map_source *current;
 	struct map_source *maps;
 	struct autofs_point *ap;
@@ -106,8 +104,6 @@ void master_source_writelock(struct master_mapent *);
 void master_source_readlock(struct master_mapent *);
 void master_source_unlock(struct master_mapent *);
 void master_source_lock_cleanup(void *);
-void master_source_current_wait(struct master_mapent *);
-void master_source_current_signal(struct master_mapent *);
 struct master_mapent *master_find_mapent(struct master *, const char *);
 struct autofs_point *master_find_mapent_by_devid(struct master *master, dev_t devid);
 struct master_mapent *master_new_mapent(struct master *, const char *, time_t);
diff --git a/modules/lookup_dir.c b/modules/lookup_dir.c
index ab1d82fb..55091b85 100644
--- a/modules/lookup_dir.c
+++ b/modules/lookup_dir.c
@@ -225,17 +225,13 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
 	return NSS_STATUS_UNKNOWN;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
 	return NSS_STATUS_UNKNOWN;
 }
 
diff --git a/modules/lookup_file.c b/modules/lookup_file.c
index 6afc5587..99f2e21b 100644
--- a/modules/lookup_file.c
+++ b/modules/lookup_file.c
@@ -689,23 +689,17 @@ prepare_plus_include(struct autofs_point *ap,
 	return new;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	char key[KEY_MAX_LEN + 1];
 	char mapent[MAPENT_MAX_LEN + 1];
 	FILE *f;
 	unsigned int k_len, m_len;
 	int entry;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	if (source->recurse)
 		return NSS_STATUS_TRYAGAIN;
 
@@ -1128,11 +1122,11 @@ static int map_update_needed(struct autofs_point *ap,
 	return ret;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	struct mapent *me;
 	char key[KEY_MAX_LEN + 1];
 	int key_len;
@@ -1143,12 +1137,6 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	int status = 0;
 	int ret = 1;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	if (source->recurse)
 		return NSS_STATUS_UNAVAIL;
 
@@ -1282,10 +1270,7 @@ do_cache_lookup:
 
 	free(lkp_key);
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
-	ret = ctxt->parse->parse_mount(ap, key, key_len,
+	ret = ctxt->parse->parse_mount(ap, source, key, key_len,
 				       mapent, ctxt->parse->context);
 	if (ret) {
 		/* Don't update negative cache when re-connecting */
diff --git a/modules/lookup_hesiod.c b/modules/lookup_hesiod.c
index 54cf278c..a8328f9a 100644
--- a/modules/lookup_hesiod.c
+++ b/modules/lookup_hesiod.c
@@ -160,11 +160,8 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	return NSS_STATUS_UNKNOWN;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	return NSS_STATUS_UNKNOWN;
 }
 
@@ -360,11 +357,11 @@ done:
 	return ret;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
 	char buf[MAX_ERR_BUF];
-	struct map_source *source;
+	struct map_source *source = map;
 	struct mapent *me;
 	char key[KEY_MAX_LEN + 1];
 	size_t key_len;
@@ -373,10 +370,6 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	char *mapent;
 	int rv;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	debug(ap->logopt,
 	      MODPREFIX "looking up root=\"%s\", name=\"%s\"",
 	      ap->path, name);
@@ -468,7 +461,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 
 	free(lkp_key);
 
-	rv = ctxt->parser->parse_mount(ap, key, key_len,
+	rv = ctxt->parser->parse_mount(ap, source, key, key_len,
 				       mapent, ctxt->parser->context);
 	free(mapent);
 
diff --git a/modules/lookup_hosts.c b/modules/lookup_hosts.c
index 9ee76fdc..bc5f1724 100644
--- a/modules/lookup_hosts.c
+++ b/modules/lookup_hosts.c
@@ -182,10 +182,7 @@ static int do_parse_mount(struct autofs_point *ap, struct map_source *source,
 {
 	int ret;
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
-	ret = ctxt->parse->parse_mount(ap, name, name_len,
+	ret = ctxt->parse->parse_mount(ap, source, name, name_len,
 				 mapent, ctxt->parse->context);
 	if (ret) {
 		struct mapent_cache *mc = source->mc;
@@ -312,11 +309,10 @@ next:
 		debug(ap->logopt, MODPREFIX
 		      "attempt to update exports for %s", entries->key);
 
-		master_source_current_wait(ap->entry);
-		ap->entry->current = source;
 		ap->flags |= MOUNT_FLAG_REMOUNT;
-		ret = ctxt->parse->parse_mount(ap, entries->key, strlen(entries->key),
-					       entries->entry, ctxt->parse->context);
+		ret = ctxt->parse->parse_mount(ap, source, entries->key,
+					       strlen(entries->key), entries->entry,
+					       ctxt->parse->context);
 		if (ret)
 			warn(ap->logopt, MODPREFIX
 			     "failed to parse mount %s", entries->entry);
@@ -326,20 +322,14 @@ next:
 	pthread_cleanup_pop(1);
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	struct hostent *host;
 	int status;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	debug(ap->logopt, MODPREFIX "read hosts map");
 
 	/*
@@ -381,23 +371,17 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	struct mapent *me;
 	char *mapent = NULL;
 	int mapent_len;
 	time_t now = monotonic_time(NULL);
 	int ret;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	/* Check if we recorded a mount fail for this key anywhere */
 	me = lookup_source_mapent(ap, name, LKP_DISTINCT);
 	if (me) {
diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
index 6b93a389..6af14163 100644
--- a/modules/lookup_ldap.c
+++ b/modules/lookup_ldap.c
@@ -83,6 +83,8 @@ struct ldap_search_params {
 
 static int decode_percent_hack(const char *, char **);
 
+pthread_mutex_t defaults_mutex = PTHREAD_MUTEX_INITIALIZER;
+
 #ifdef WITH_SASL
 static int set_env(unsigned logopt, const char *name, const char *val)
 {
@@ -3135,17 +3137,13 @@ static int read_one_map(struct autofs_point *ap,
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
+	struct map_source *source = map;
 	int rv = LDAP_SUCCESS;
 	int ret, cur_state;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cur_state);
 	ret = read_one_map(ap, source, ctxt, age, &rv);
 	if (ret != NSS_STATUS_SUCCESS) {
@@ -3758,7 +3756,7 @@ static int check_map_indirect(struct autofs_point *ap,
 
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cur_state);
 
-	status = pthread_mutex_lock(&ap->entry->current_mutex);
+	status = pthread_mutex_lock(&defaults_mutex);
 	if (status)
 		fatal(status);
 	if (is_amd_format) {
@@ -3780,7 +3778,7 @@ static int check_map_indirect(struct autofs_point *ap,
 				ctxt->check_defaults = 0;
 		}
 	}
-	status = pthread_mutex_unlock(&ap->entry->current_mutex);
+	status = pthread_mutex_unlock(&defaults_mutex);
 	if (status)
 		fatal(status);
 
@@ -3827,12 +3825,12 @@ static int check_map_indirect(struct autofs_point *ap,
 		}
 		cache_unlock(mc);
 
-		status = pthread_mutex_lock(&ap->entry->current_mutex);
+		status = pthread_mutex_lock(&defaults_mutex);
 		if (status)
 			fatal(status);
 		if (t_last_read > ap->exp_runfreq && ret & CHE_UPDATED)
 			source->stale = 1;
-		status = pthread_mutex_unlock(&ap->entry->current_mutex);
+		status = pthread_mutex_unlock(&defaults_mutex);
 		if (status)
 			fatal(status);
 	}
@@ -3848,11 +3846,11 @@ static int check_map_indirect(struct autofs_point *ap,
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	struct mapent *me;
 	char key[KEY_MAX_LEN + 1];
 	int key_len;
@@ -3863,12 +3861,6 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	int status = 0;
 	int ret = 1;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	debug(ap->logopt, MODPREFIX "looking up %s", name);
 
 	if (!(source->flags & MAP_FLAG_FORMAT_AMD)) {
@@ -3997,10 +3989,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 
 	free(lkp_key);
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
-	ret = ctxt->parse->parse_mount(ap, key, key_len,
+	ret = ctxt->parse->parse_mount(ap, source, key, key_len,
 				       mapent, ctxt->parse->context);
 	if (ret) {
 		/* Don't update negative cache when re-connecting */
diff --git a/modules/lookup_multi.c b/modules/lookup_multi.c
index cf109de9..23a1b8a2 100644
--- a/modules/lookup_multi.c
+++ b/modules/lookup_multi.c
@@ -525,20 +525,14 @@ int lookup_read_master(struct master *master, time_t age, void *context)
         return NSS_STATUS_UNKNOWN;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
+	struct map_source *source = map;
 	int i, ret, at_least_1 = 0;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	for (i = 0; i < ctxt->n; i++) {
-		master_source_current_wait(ap->entry);
-		ap->entry->current = source;
-		ret = ctxt->m[i].mod->lookup_read_map(ap, age,
+		ret = ctxt->m[i].mod->lookup_read_map(ap, source, age,
 						ctxt->m[i].mod->context);
 		if (ret & LKP_FAIL || ret == LKP_NOTSUP)
 			continue;
@@ -552,20 +546,14 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
+	struct map_source *source = map;
 	int i;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	for (i = 0; i < ctxt->n; i++) {
-		master_source_current_wait(ap->entry);
-		ap->entry->current = source;
-		if (ctxt->m[i].mod->lookup_mount(ap, name, name_len,
+		if (ctxt->m[i].mod->lookup_mount(ap, source, name, name_len,
 						 ctxt->m[i].mod->context) == 0)
 			return NSS_STATUS_SUCCESS;
 	}
diff --git a/modules/lookup_nisplus.c b/modules/lookup_nisplus.c
index 6e9a85d1..335113be 100644
--- a/modules/lookup_nisplus.c
+++ b/modules/lookup_nisplus.c
@@ -220,11 +220,11 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	char *tablename;
 	nis_result *result;
 	nis_object *this;
@@ -233,10 +233,6 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 	char buf[MAX_ERR_BUF];
 	int cur_state;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	/*
 	 * If we don't need to create directories (or don't need
 	 * to read an amd cache:=all map) then there's no use
@@ -670,11 +666,11 @@ static int check_map_indirect(struct autofs_point *ap,
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	char key[KEY_MAX_LEN + 1];
 	int key_len;
 	char *lkp_key;
@@ -685,12 +681,6 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	int status;
 	int ret = 1;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	debug(ap->logopt, MODPREFIX "looking up %s", name);
 
 	if (!(source->flags & MAP_FLAG_FORMAT_AMD)) {
@@ -821,10 +811,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 
 	free(lkp_key);
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
-	ret = ctxt->parse->parse_mount(ap, key, key_len,
+	ret = ctxt->parse->parse_mount(ap, source, key, key_len,
 				       mapent, ctxt->parse->context);
 	if (ret) {
 		free(mapent);
diff --git a/modules/lookup_program.c b/modules/lookup_program.c
index b5eb1117..fd90fb87 100644
--- a/modules/lookup_program.c
+++ b/modules/lookup_program.c
@@ -166,11 +166,8 @@ int lookup_read_master(struct master *master, time_t age, void *context)
         return NSS_STATUS_UNKNOWN;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	return NSS_STATUS_UNKNOWN;
 }
 
@@ -585,21 +582,15 @@ static int match_key(struct autofs_point *ap,
 	return ret;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	char *mapent = NULL;
 	struct mapent *me;
 	int ret = 1;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	/* Check if we recorded a mount fail for this key anywhere */
 	me = lookup_source_mapent(ap, name, LKP_DISTINCT);
 	if (me) {
@@ -649,10 +640,9 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 				strcpy(ent, me->mapent);
 			}
 			cache_unlock(mc);
-			master_source_current_wait(ap->entry);
-			ap->entry->current = source;
-			ret = ctxt->parse->parse_mount(ap, name,
-				 name_len, ent, ctxt->parse->context);
+			ret = ctxt->parse->parse_mount(ap, source,
+						       name, name_len, ent,
+						       ctxt->parse->context);
 			if (ent)
 				free(ent);
 			goto out_free;
@@ -684,10 +674,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 
 	debug(ap->logopt, MODPREFIX "%s -> %s", name, mapent);
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
-	ret = ctxt->parse->parse_mount(ap, name, name_len,
+	ret = ctxt->parse->parse_mount(ap, source, name, name_len,
 				       mapent, ctxt->parse->context);
 out_free:
 	if (mapent)
diff --git a/modules/lookup_sss.c b/modules/lookup_sss.c
index 43545b0c..7eb7e783 100644
--- a/modules/lookup_sss.c
+++ b/modules/lookup_sss.c
@@ -771,23 +771,17 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	void *sss_ctxt = NULL;
 	char *key;
 	char *value = NULL;
 	char *s_key;
 	int count, ret;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	/*
 	 * If we don't need to create directories (or don't need
 	 * to read an amd cache:=all map) then there's no use
@@ -873,11 +867,10 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 	return NSS_STATUS_SUCCESS;
 }
 
-static int lookup_one(struct autofs_point *ap,
-		char *qKey, int qKey_len, struct lookup_context *ctxt)
+static int lookup_one(struct autofs_point *ap, struct map_source *source,
+		      char *qKey, int qKey_len, struct lookup_context *ctxt)
 {
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct mapent_cache *mc = source->mc;
 	struct mapent *we;
 	void *sss_ctxt = NULL;
 	time_t age = monotonic_time(NULL);
@@ -885,12 +878,6 @@ static int lookup_one(struct autofs_point *ap,
 	char *s_key;
 	int err, ret;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	ret = setautomntent(ap->logopt, ctxt, &sss_ctxt, SSS_LOOKUP_KEY);
 	if (ret)
 		return ret;
@@ -983,24 +970,14 @@ wild:
 }
 
 static int check_map_indirect(struct autofs_point *ap,
-			      char *key, int key_len,
+			      struct map_source *source, char *key, int key_len,
 			      struct lookup_context *ctxt)
 {
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct mapent_cache *mc = source->mc;
 	int ret, cur_state;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cur_state);
-	ret = lookup_one(ap, key, key_len, ctxt);
+	ret = lookup_one(ap, source, key, key_len, ctxt);
 	if (ret == NSS_STATUS_NOTFOUND) {
 		pthread_setcancelstate(cur_state, NULL);
 		return ret;
@@ -1026,11 +1003,11 @@ static int check_map_indirect(struct autofs_point *ap,
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	struct mapent *me;
 	char key[KEY_MAX_LEN + 1];
 	int key_len;
@@ -1038,12 +1015,6 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	char mapent_buf[MAPENT_MAX_LEN + 1];
 	int ret;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	debug(ap->logopt, MODPREFIX "looking up %s", name);
 
 	key_len = snprintf(key, KEY_MAX_LEN + 1, "%s", name);
@@ -1078,10 +1049,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		if (!lkp_key)
 			return NSS_STATUS_UNKNOWN;
 
-		master_source_current_wait(ap->entry);
-		ap->entry->current = source;
-
-		status = check_map_indirect(ap, lkp_key, strlen(lkp_key), ctxt);
+		status = check_map_indirect(ap, source, lkp_key, strlen(lkp_key), ctxt);
 		free(lkp_key);
 		if (status)
 			return status;
@@ -1128,11 +1096,9 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	if (!mapent)
 		return NSS_STATUS_TRYAGAIN;
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
 	debug(ap->logopt, MODPREFIX "%s -> %s", key, mapent);
-	ret = ctxt->parse->parse_mount(ap, key, key_len,
+
+	ret = ctxt->parse->parse_mount(ap, source, key, key_len,
 				       mapent, ctxt->parse->context);
 	if (ret) {
 		/* Don't update negative cache when re-connecting */
diff --git a/modules/lookup_userhome.c b/modules/lookup_userhome.c
index 8117640f..80bf04eb 100644
--- a/modules/lookup_userhome.c
+++ b/modules/lookup_userhome.c
@@ -46,27 +46,19 @@ int lookup_read_master(struct master *master, time_t age, void *context)
         return NSS_STATUS_UNKNOWN;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
 	return NSS_STATUS_UNKNOWN;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	struct passwd *pw;
 	char buf[MAX_ERR_BUF];
 	int ret;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	debug(ap->logopt, MODPREFIX "looking up %s", name);
 
 	/* Get the equivalent username */
diff --git a/modules/lookup_yp.c b/modules/lookup_yp.c
index d2a4b5a5..40ca31a8 100644
--- a/modules/lookup_yp.c
+++ b/modules/lookup_yp.c
@@ -59,6 +59,8 @@ struct callback_data {
 
 int lookup_version = AUTOFS_LOOKUP_VERSION;	/* Required by protocol */
 
+static pthread_mutex_t defaults_mutex = PTHREAD_MUTEX_INITIALIZER;
+
 static unsigned int get_map_order(const char *domain, const char *map)
 {
 	char key[] = "YP_LAST_MODIFIED";
@@ -392,20 +394,16 @@ int yp_all_callback(int status, char *ypkey, int ypkeylen,
 	return 0;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
 	struct ypall_callback ypcb;
 	struct callback_data ypcb_data;
 	unsigned int logopt = ap->logopt;
-	struct map_source *source;
+	struct map_source *source = map;
 	char *mapname;
 	int err;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	/*
 	 * If we don't need to create directories (or don't need
 	 * to read an amd cache:=all map) then there's no use
@@ -457,9 +455,9 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 	}
 
 	source->age = age;
-	pthread_mutex_lock(&ap->entry->current_mutex);
+	pthread_mutex_lock(&defaults_mutex);
 	ctxt->check_defaults = 0;
-	pthread_mutex_unlock(&ap->entry->current_mutex);
+	pthread_mutex_unlock(&defaults_mutex);
 
 	return NSS_STATUS_SUCCESS;
 }
@@ -685,7 +683,7 @@ static int check_map_indirect(struct autofs_point *ap,
 	mc = source->mc;
 
 	/* Only read map if it has been modified */
-	pthread_mutex_lock(&ap->entry->current_mutex);
+	pthread_mutex_lock(&defaults_mutex);
 	map_order = get_map_order(ctxt->domainname, ctxt->mapname);
 	if (map_order > ctxt->order) {
 		ctxt->order = map_order;
@@ -702,7 +700,7 @@ static int check_map_indirect(struct autofs_point *ap,
 		} else
 			ctxt->check_defaults = 0;
 	}
-	pthread_mutex_unlock(&ap->entry->current_mutex);
+	pthread_mutex_unlock(&defaults_mutex);
 
 	/* check map and if change is detected re-read map */
 	ret = match_key(ap, source, key, key_len, ctxt);
@@ -782,11 +780,11 @@ static int check_map_indirect(struct autofs_point *ap,
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	char key[KEY_MAX_LEN + 1];
 	int key_len;
 	char *lkp_key;
@@ -797,12 +795,6 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	int status = 0;
 	int ret = 1;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	debug(ap->logopt, MODPREFIX "looking up %s", name);
 
 	if (!(source->flags & MAP_FLAG_FORMAT_AMD)) {
@@ -939,10 +931,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 
 	free(lkp_key);
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
-	ret = ctxt->parse->parse_mount(ap, key, key_len,
+	ret = ctxt->parse->parse_mount(ap, source, key, key_len,
 				       mapent, ctxt->parse->context);
 	free(mapent);
 	if (ret) {
diff --git a/modules/parse_amd.c b/modules/parse_amd.c
index 1a46ae0d..fb6b1b76 100644
--- a/modules/parse_amd.c
+++ b/modules/parse_amd.c
@@ -1390,12 +1390,9 @@ static int do_host_mount(struct autofs_point *ap, const char *name,
 		cache_push_mapent(me, NULL);
 	cache_unlock(source->mc);
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = instance;
-
 	map_module_readlock(instance);
 	lookup = instance->lookup;
-	ret = lookup->lookup_mount(ap, entry->rhost,
+	ret = lookup->lookup_mount(ap, instance, entry->rhost,
 				   strlen(entry->rhost), lookup->context);
 	map_module_unlock(instance);
 
@@ -2210,13 +2207,14 @@ done:
 	return defaults_entry;
 }
 
-int parse_mount(struct autofs_point *ap, const char *name,
-		int name_len, const char *mapent, void *context)
+int parse_mount(struct autofs_point *ap, struct map_source *map,
+		const char *name, int name_len, const char *mapent,
+		void *context)
 {
 	struct parse_context *ctxt = (struct parse_context *) context;
 	unsigned int flags = conf_amd_get_flags(ap->path);
 	struct substvar *sv = NULL;
-	struct map_source *source;
+	struct map_source *source = map;
 	unsigned int at_least_one;
 	struct list_head entries, *p, *head;
 	struct amd_entry *defaults_entry;
@@ -2226,10 +2224,6 @@ int parse_mount(struct autofs_point *ap, const char *name,
 	int cur_state;
 	int ret;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	if (!mapent) {
 		warn(ap->logopt, MODPREFIX "error: empty map entry");
 		return 1;
diff --git a/modules/parse_hesiod.c b/modules/parse_hesiod.c
index a02da822..810b4053 100644
--- a/modules/parse_hesiod.c
+++ b/modules/parse_hesiod.c
@@ -272,8 +272,9 @@ int parse_done(void *context)
 	return 0;
 }
 
-int parse_mount(struct autofs_point *ap, const char *name,
-		int name_len, const char *mapent, void *context)
+int parse_mount(struct autofs_point *ap, struct map_source *map,
+		const char *name, int name_len, const char *mapent,
+		void *context)
 {
 	char source[HESIOD_LEN + 1];
 	char fstype[HESIOD_LEN + 1];
@@ -282,9 +283,6 @@ int parse_mount(struct autofs_point *ap, const char *name,
 	const char *p;
 	int ret;
 
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	p = mapent;
 	q = fstype;
 
diff --git a/modules/parse_sun.c b/modules/parse_sun.c
index 09ec6d4d..cb3e22a0 100644
--- a/modules/parse_sun.c
+++ b/modules/parse_sun.c
@@ -1310,13 +1310,14 @@ static void cleanup_offset_entries(struct autofs_point *ap,
  * level nexting point. Finally to mount non multi-mounts and to mount a
  * lower level multi-mount nesting point and its offsets.
  */
-int parse_mount(struct autofs_point *ap, const char *name,
-		int name_len, const char *mapent, void *context)
+int parse_mount(struct autofs_point *ap, struct map_source *map,
+		const char *name, int name_len, const char *mapent,
+		void *context)
 {
 	struct parse_context *ctxt = (struct parse_context *) context;
 	char buf[MAX_ERR_BUF];
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	struct mapent *me, *oe, *tmp;
 	LIST_HEAD(offsets);
 	char *pmapent, *options;
@@ -1326,12 +1327,6 @@ int parse_mount(struct autofs_point *ap, const char *name,
 	int slashify = ctxt->slashify_colons;
 	unsigned int append_options;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	if (!mapent) {
 		warn(ap->logopt, MODPREFIX "error: empty map entry");
 		return 1;
